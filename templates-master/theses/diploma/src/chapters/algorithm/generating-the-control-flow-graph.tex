\section{Generating the control flow graph}

The body of the \code{while} statement previously generated will contain a \code{switch} statement, whose body will
contain \code{case}s for each \textit{basic block} in the original body of the method, as defined below.

Because the Java programming language does not provide a \code{goto} statement, there is no direct a way of jumping at
a later point in code (useful when returning from a recursive call to execute the statements after the call). But this
problem can be solved if the code can be broken into \textit{basic blocks}, by generating the control flow graph of the
method body. Each basic block will correspond to a \code{case} in the \code{switch} statement from above. Jumping
between different blocks is possible by using the \code{block} field of the \code{frame} object.

The structure of the CFG (Control Flow Graph) \abbrev{CFG}{Control Flow Graph} presented here is inspired from LLVM
IR\footnote{\url{https://llvm.org/docs/LangRef.html}}.

In this context, a \code{Block} is defined as a list of non-terminal \code{NormalStatement}s terminated by a
\code{TerminatorStatement}.

A \code{NormalStatement} is a wrapper for a \code{PsiStatement}.

A \code{TerminatorStatement} is either a \code{ReturnStatement}, a \code{ConditionalJumpStatement} or an
\code{UnconditionalJumpStatement}.

A \code{ReturnStatement} is a wrapper for a \code{PsiReturnStatement}.

A \code{ConditionalJumpStatement} jumps from the containing \code{Block} to one of two \code{Block}s, based on the
value of a \code{PsiExpression}.

An \code{UnconditionalJumpStatement} jumps from the containing \code{Block} to another \code{Block}.

The list of \code{Block}s for the method body is generated by a \code{JavaRecursiveElementVisitor}, which performs
different operations for each type of \code{PsiElement} encountered. Each \code{Block} has an \code{id} field which
represents the label of its corresponding \code{case}.

The visitor initializes a \code{currentBlock} before visiting the actual body of the method. This is the entry block of
the function. The following subsections present how the visitor processes each type of relevant \code{PsiElement}
encountered.

\subsection{Visiting a \code{PsiCodeBlock}}

The body of a method is represented as a \code{PsiCodeBlock}. The visitor processes each\\
\code{PsiStatement} in the \code{PsiCodeBlock}.

In this context, processing means that if the \code{PsiStatement} contains recursive calls, it
accepts the visitor for further processing. If the \code{PsiStatement} is an instance of \code{PsiReturnStatement}, a
\code{ReturnStatement} wrapper over the \code{PsiStatement} is added to the \code{currentBlock}. Otherwise, a
\code{NormalStatement} wrapper over the \code{PsiStatement} is added to the \code{currentBlock}.

An important last step after processing all the \code{PsiStatement}s in the \code{PsiCodeBlock} of the method is adding
an explicit \code{ReturnStatement} to the \code{currentBlock}, if the return type of the method is \code{void} and the
body does not already contain an explicit \code{return} statement. This is almost always the case because these methods
do not specify a final \code{return} statement, since it is redundant.

\subsection{Visiting a \code{PsiBlockStatement}}
Since the \code{PsiBlockStatement} is merely a wrapper over a \code{PsiCodeBlock}, visiting it translates to processing
the statements of its contained \code{PsiCodeBlock}, just as already specified above.

\subsection{Visiting a \code{PsiMethodCallExpression}}

Given the previous passes and the processing of \code{PsiStatement}s presented above, the visitor actually visits only
recursive calls. These calls appear only as right-hand sides of\\
\code{PsiAssignmentExpression}s or as initializers of \code{PsiVariable}s in\\
\code{PsiDeclarationStatement}s (generated by the \textit{Extracting recursive calls to statements} pass).

The recursive call is transformed in a \code{push} call to the \code{stack}, where the new \code{frame} object is
initialized using the \code{PsiExpression}s provided as arguments to the recursive call. A new \code{Block} is generated
and it is marked as a block appearing after a recursive call, so it will not be considered for inlining by later passes.
Then an \code{UnconditionalJumpStatement} which jumps to the new block is added to the \code{currentBlock}. After this,
the \code{currentBlock} is changed to the new block. The \code{PsiStatement} in which the recursive call appears is
added to the new \code{currentBlock}, but having the recursive call replaced with a \code{PsiExpression} referring to
the \code{ret} variable.

\subsection{Visiting an \code{PsiIfStatement}}

Two new blocks are generated: the \code{thenBlock} and the \code{mergeBlock}. An optional third block (the
\code{elseBlock}) gets generated if the \code{if} statement has an \code{else} branch. A\\
\code{ConditionalJumpStatement} is added to the \code{currentBlock}. It jumps to the \code{thenBlock} or the
\code{elseBlock}. If there is no \code{elseBlock}, it jumps to the \code{mergeBlock} instead.

The \code{currentBlock} is now set to the \code{thenBlock} and the \code{then} branch accepts the visitor. After this,
an \code{UnconditionalJumpStatement} to the \code{mergeBlock} is added to the \code{currentBlock}, which may be other
than the \code{thenBlock}, because of the visitor possibly changing it when visiting the \code{then} branch.

If there is an \code{else} branch, it is treated similarly to the \code{then} branch. Finally, the \code{currentBlock}
is set to the \code{mergeBlock}.

The description above is depicted in \labelindexref{Figure}{img:if-statement}. The grey boxes represent basic blocks
which are optional and the dotted lines represent arbitrary subgraphs.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{src/graph/graph.pdf}
    \caption{If statement CFG\label{img:if-statement}}
\end{figure}

\subsection{Visiting a \code{PsiWhileStatement}}

Three new blocks are generated: the \code{conditionBlock}, the \code{bodyBlock} and the \code{mergeBlock}. Then an
\code{UnconditionalJumpStatement} to the \code{conditionBlock} is added to the\\
\code{currentBlock}.

The \code{currentBlock} is set to the \code{conditionBlock}. Here a \code{ConditionalJumpStatement} is added to the
\code{conditionBlock}. It jumps to either the \code{bodyBlock} or the \code{mergeBlock} depending on the \code{while}
statement condition.

The \code{currentBlock} is then set to the \code{bodyBlock} and the visitor visits the body of the \code{while}
statement. Then an \code{UnconditionalJumpStatement} to the \code{conditionBlock} is added to the \code{currentBlock},
which may be other than the \code{bodyBlock}, because of the visitor possibly changing it when visiting the body of the
\code{while} statement.

Finally, the \code{currentBlock} is set to the \code{mergeBlock}.

The description above is depicted in \labelindexref{Figure}{img:while-statement}. The dotted lines represent arbitrary subgraphs.

\subsection{Visiting a \code{PsiDoWhileStatement}}

Visiting a \code{PsiDoWhileStatement} is analogous to visiting a \code{PsiWhileStatement}. The only difference is that
the initial \code{UnconditionalJumpStatement} is to the \code{bodyBlock} instead of to the \code{conditionBlock},
because a \code{do-while} statement executes its body at least once.

The description above is depicted in \labelindexref{Figure}{img:do-while-statement}. The dotted lines represent arbitrary subgraphs.

\begin{figure}[htb]
    \centering
    \begin{minipage}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{src/graph/while.pdf}
        \caption{While statement CFG\label{img:while-statement}}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{src/graph/do-while.pdf}
        \caption{Do-while statement CFG\label{img:do-while-statement}}
    \end{minipage}
\end{figure}

\subsection{Visiting a \code{PsiForStatement}}

If the \code{PsiForStatement} has any initialization, the corresponding \code{PsiStatement}s are added to the
\code{currentBlock}. There are three cases here, based on how Intellij IDEA parses the initialization part of a
\code{for} statement. If the initialization is an instance of \code{PsiEmptyStatement}, there is no actual statement to
add. If the initialization is an instance of\\
\code{PsiExpressionStatement}, this statement is added to the \code{currentBlock}. Finally, if the initialization is an
instance of \code{PsiExpressionListStatement}, each expression in this list is added as a statement to the
\code{currentBlock}. The case when the initialization is a \code{PsiDeclarationStatement} is not valid here, because of
the \textit{Replace declarations having initializers with assignments} pass.

Then an \code{UnconditionalJumpStatement} to the \code{actualConditionBlock} is added to the \code{currentBlock}. The
\code{actualConditionBlock} is either the \code{conditionBlock} if the \code{for} statement has a condition or the
\code{bodyBlock} otherwise.

If the \code{for} statement has a condition, the \code{currentBlock} is set to the \code{conditionBlock} and a
\code{ConditionalJumpStatement} is added to the \code{currentBlock}. It jumps to either the \code{bodyBlock} or the
\code{mergeBlock} based on the condition of the \code{for} statement.

If the \code{for} statement has an update, the \code{currentBlock} is set to the \code{updateBlock}. The statements
corresponding to the update of the \code{for} statement are added to the \code{currentBlock}, in a similar fashion to
the statements corresponding to the initialization of the \code{for} statement. Then an \code{UnconditionalJumpStatement}
to the \code{actualConditionBlock} is added to the \code{currentBlock}.

The \code{currentBlock} is then set to the \code{bodyBlock} and the visitor visits the body of the \code{for} statement.
After this, an \code{UnconditionalJumpStatement} to the \code{actualUpdateBlock} is added to the \code{currentBlock}, which
may not be the \code{bodyBlock} anymore, because of the visitor possibly changing it when visiting the body of the
\code{for} statement. The \code{actualUpdateBlock} is either the \code{updateBlock} if the \code{for} statement has
an update or the \code{actualConditionBlock} otherwise.

Finally, the \code{currentBlock} is set to the \code{mergeBlock}.

The description above is depicted in \labelindexref{Figure}{img:for-statement}. The grey boxes represent basic blocks
which are optional and the dotted lines represent arbitrary subgraphs.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{src/graph/for.pdf}
    \caption{For statement CFG\label{img:for-statement}}
\end{figure}

An example of the generated basic blocks is provided in \labelindexref{Figure}{img:blocks}. Each block is assigned to
a case inside a \code{switch} statement which replaces the incorporated body of the method. The \code{switch} statement
has the \code{block} field of the \code{frame} object as its expression.

\begin{figure}[htb]
    \makebox[\linewidth][c]{%
    \begin{subfigure}[b]{.6\textwidth}
        \centering
        \includegraphics[height=3in]{src/img/blocks-before.png}
        \caption{Before}
    \end{subfigure}%
    \begin{subfigure}[b]{.6\textwidth}
        \centering
        \includegraphics[height=5.25in]{src/img/blocks-after.png}
        \caption{After}
    \end{subfigure}%
    }\\
    \caption{Generating the control flow graph \label{img:blocks}}
\end{figure}